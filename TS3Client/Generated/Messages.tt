// TS3Client - A free TeamSpeak3 client implementation
// Copyright (C) 2017  TS3Client contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.

<#@ output extension=".cs" #>
<#@ template debug="false" hostSpecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#= "// *** DO NOT EDIT THIS FILE, IT HAS BEEN AUTO-GENERATED ***" #>

namespace TS3Client.Messages
{
	using Commands;
	using Helper;
	using System;
	using System.Globalization;

	using UidT = System.String;
	using ClientDbIdT = System.UInt64;
	using ClientIdT = System.UInt16;
	using ChannelIdT = System.UInt64;
	using ServerGroupIdT = System.UInt64;
	using ChannelGroupIdT = System.UInt64;

<#
	string declFilePath = Host.ResolvePath("../Declarations/Messages.txt");
	string[] declLines = File.ReadAllLines(declFilePath);
	
	var fldDict = new Dictionary<string, GenField>();
	var msgDict = new Dictionary<string, GenMsg>();
	var ntfyDict = new Dictionary<string, GenNotify>();
	var convSet = new Dictionary<string, GenType>();

	string GenerateDeserializer(GenField fld)
	{
		if(fld.isArray)
			return $"{{ if(value.Length == 0) {fld.fldName} = new {fld.fldType}[0]; else {{"
			     + $" var ss = new SpanSplitter(); ss.First(value, ',');"
			     + $" int cnt = 0; for (int i = 0; i < value.Length; i++) if (value[i] == ',') cnt++;"
			     + $" {fld.fldName} = new {fld.fldType}[cnt + 1];"
			     + $" for(int i = 0; i < cnt + 1; i++) {{ {GenerateSingleDeserializer(fld, "ss.Trim(value)", fld.fldName + "[i]")} if (i < cnt) value = ss.Next(value); }} }} }}";
		else
			return GenerateSingleDeserializer(fld, "value", fld.fldName);
	}

	string GenerateSingleDeserializer(GenField fld, string input, string output)
	{
		GenType typeInfo;
		if(!convSet.TryGetValue(fld.fldType, out typeInfo))
			throw new Exception("Unregistered type");
		switch (fld.fldType)
		{
		case "bool":
			return $"{output} = {input}.Length > 0 && {input}[0] != '0';";
		case "sbyte":
		case "byte":
		case "short":
		case "ushort":
		case "int":
		case "uint":
		case "long":
		case "ulong":
		case "float":
		case "double":
		case "ClientDbIdT":
		case "ClientIdT":
		case "ChannelIdT":
		case "ServerGroupIdT":
		case "ChannelGroupIdT":
			return $"{output} = {fld.fldType}.Parse({input}.NewString(), CultureInfo.InvariantCulture);";
		case "TimeSpanSecondsT":
			return $"{output} = TimeSpan.FromSeconds(double.Parse({input}.NewString(), CultureInfo.InvariantCulture));";
		case "TimeSpanMillisecT":
			return $"{output} = TimeSpan.FromMilliseconds(double.Parse({input}.NewString(), CultureInfo.InvariantCulture));";
		case "DateTime":
			return $"{output} = Util.UnixTimeStart.AddSeconds(double.Parse({input}.NewString(), CultureInfo.InvariantCulture));";
		case "string":
		case "UidT":
			return $"{output} = Ts3String.Unescape({input});";
		case "HostMessageMode":
		case "CodecEncryptionMode":
		case "HostBannerMode":
		case "MoveReason":
		case "ClientType":
		case "TextMessageTargetMode":
		case "PermissionGroupDatabaseType":
		case "GroupNamingMode":
			return $"{{ if (!Enum.TryParse({input}.NewString(), out {fld.fldType} val)) throw new FormatException(); {output} = val; }}";
		case "Codec":
		case "Ts3ErrorCode":
		case "LicenseType":
		case "PermissionId":
			return $"{output} = ({fld.fldType}){typeInfo.backingType}.Parse({input}.NewString(), CultureInfo.InvariantCulture);";
		case "IconHash":
			return $"{output} = unchecked((int)long.Parse({input}.NewString(), CultureInfo.InvariantCulture));";
		default:
			return "#error missing deserializer";
		}
	}

	string GenerateType(GenField fld)
	{
		string final;
		switch (fld.fldType)
		{
		case "TimeSpanSecondsT": final = "TimeSpan"; break;
		case "TimeSpanMillisecT": final = "TimeSpan"; break;
		case "IconHash": final = "int"; break;
		default: final = fld.fldType; break;
		}

		return final + (fld.isArray ? "[]" : "");
	}

	foreach(var line in declLines)
	{
		if(string.IsNullOrWhiteSpace(line))
			continue;

		var parts = line.Split(new [] {':'}, 2);
		if(parts.Length < 2 || string.IsNullOrWhiteSpace(parts[0]))
			continue;

		parts[0] = parts[0].Trim().ToUpper();
		if(parts[0] == "MSG")
		{
			var param = parts[1].Replace(" ", "").Split(',');
			if(param.Length < 2) { this.Write("#warning Invalid MSG: " + line); continue; }
			msgDict.Add(param[0], new GenMsg { className=param[0], ntfyName=param[1] } );

			bool isNotify = !string.IsNullOrEmpty(param[1]);
			bool isResponse = string.IsNullOrEmpty(param[1]) || param[1].StartsWith("+");
			GenNotify genNotify = null;
			if(isNotify)
			{
				genNotify = ntfyDict[param[1].TrimStart('+')];
				genNotify.assocMsg = msgDict[param[0]];
			}
#>
	public sealed class <#= param[0] #> : <#= isNotify ? "INotification" : "" #> <#= (isNotify && isResponse) ? "," : "" #> <#= isResponse ? "IResponse" : "" #>
	{
		<#= isNotify ? "public NotificationType NotifyType { get; } = NotificationType." + genNotify.enumName + ";" : "" #>
		<#= isResponse ? "public string ReturnCode { get; set; }" : "" #>
<#
			for(int i = 2; i < param.Length; i++)
			{
				GenField genField;
				if(!fldDict.TryGetValue(param[i], out genField)) { this.Write(Environment.NewLine + "#warning Missing Field: " + param[i]); continue; }
#>
		public <#= genField.genType #> <#= genField.fldName #> { get; set; }<#
			}
#>

		public void SetField(string name, ReadOnlySpan<char> value)
		{
<#
			if (param.Length > 2) {#>
			switch(name)
			{
<#
			for(int i = 2; i < param.Length; i++)
			{
				GenField genField;
				if(!fldDict.TryGetValue(param[i], out genField)) { this.Write(Environment.NewLine + "#warning Missing Field: " + param[i]); continue; }
#>
			case "<#= genField.tsName #>": <#= GenerateDeserializer(genField) #> break;<#
			}
#>
			<#= isNotify ? "" : ("case \"return_code\": " + GenerateDeserializer(fldDict["return_code"]) + " break;") #>
			}
<#
			}#>
		}
	}
<#
		}
		else if(parts[0] == "FIELD")
		{
			var param = parts[1].Replace(" ", "").Split(',');
			if(param.Length < 4) { this.Write("#warning Invalid FIELD: " + line); continue; }
			var fld = new GenField { tsName=param[1], fldName=param[2], fldType=param[3], isArray = false, isOpt = false };
			if(fld.fldType.EndsWith("[]"))
			{
				fld.isArray = true;
				fld.fldType = fld.fldType.Substring(0, fld.fldType.Length - 2);
			}
			if(fld.fldType.EndsWith("?"))
			{
				fld.isOpt = true;
				fld.fldType = fld.fldType.Substring(0, fld.fldType.Length - 1);
			}
			fld.genType = GenerateType(fld);
			fldDict.Add(param[0], fld );
		}
		else if(parts[0] == "NOTIFY")
		{
			var param = parts[1].Replace(" ", "").Split(',');
			if(param.Length < 2) { this.Write("#warning Invalid NOTIFY: " + line); continue; }
			ntfyDict.Add(param[0], new GenNotify { enumName=param[1] } );
		}
		else if(parts[0] == "TYPE")
		{
			var param = parts[1].Replace(" ", "").Split(',');
			if(param.Length != 1 && param.Length != 2) { this.Write("#warning Invalid TYPE: " + line); continue; }
			convSet.Add(param[0], new GenType { typeName = param[0], backingType = param.Length > 1 ? param[1] : null });
		}
		else if(parts[0] == "BREAK")
		{
			break;
		}
	}
#>
	public enum NotificationType
	{
		Unknown,
<# foreach(var kvp in ntfyDict) { #>
		<#= kvp.Value.enumName #>,<#
	}
#>
	}

	public static class MessageHelper
	{
		public static NotificationType GetNotificationType(string name)
		{
			switch(name)
			{
<# foreach(var kvp in ntfyDict) { #>
			case "<#= kvp.Key #>": return NotificationType.<#= kvp.Value.enumName #>;<#
	}
#>
			default: return NotificationType.Unknown;
			}
		}

		public static INotification GenerateNotificationType(NotificationType name)
		{
			switch(name)
			{
<#
	foreach(var kvp in ntfyDict)
	{
#>
			<#= kvp.Value.assocMsg == null ? "#warning " : "" #>case NotificationType.<#= kvp.Value.enumName #>: return new <#= kvp.Value.assocMsg?.className ?? "" #>();<#
	}
#>
			case NotificationType.Unknown:
			default: throw Util.UnhandledDefault(name);
			}
		}
	}
}

<#+	class GenField
{
	public string tsName;
	public string fldName; // propety name
	public string fldType; // single type
	public string genType; // final property Type
	public bool isArray;
	public bool isOpt;
}
class GenMsg
{
	public string className;
	public string ntfyName;
}
class GenNotify
{
	public string enumName;
	public GenMsg assocMsg;
}
class GenType
{
	public string typeName;
	public string backingType;
}
#>