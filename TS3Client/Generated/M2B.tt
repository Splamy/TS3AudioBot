// TS3Client - A free TeamSpeak3 client implementation
// Copyright (C) 2017  TS3Client contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />

<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ include file="M2BParser.ttinclude" once="true" #>
<#@ include file="MessageParser.ttinclude" once="true" #>
<#@ include file="BookParser.ttinclude" once="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
var genbook = BookDeclarations.Parse(Host.ResolvePath("../Declarations/BookDeclarations.toml"));
var genmsg = Messages.Parse(Host.ResolvePath("../Declarations/Messages.toml"));
var genm2b = M2BDeclarations.Parse(Host.ResolvePath("../Declarations/MessagesToBook.toml"), genmsg, genbook);
#>

namespace TS3Client.Full.Book
{
	using Messages;

	<#= ConversionSet #>

	public partial class Connection
	{
#pragma warning disable IDE0017 // Ignore "Object initialization can be simplified"
	<# foreach (var rule in genm2b.rule) {
		var msg = genmsg.NotifiesSorted.First(x => x.name == rule.from);
		var bookItem = genbook.@struct.First(x => x.name == rule.to);
	#>
		public void Update<#= msg.name #>(<#= msg.name #> msg)
		{
			<# var idStr = string.Join(", ", rule.id.Select(x => $"msg.{x}"));

		ClearIndent();
		PushIndent("\t\t\t");
		switch (rule.operation)
		{
		case "add":
		case "update":
			if (rule.operation == "add")
				WriteLine($"var obj = new {rule.to}();");
			else
				WriteLine($"var obj = Get{rule.to}({idStr});");

			foreach (var prop in rule.properties) {
				void WriteMove(string from, string to) {
					var bookProp = bookItem.properties.FirstOrDefault(x => x.name == to);
					if(bookProp is null) {
						Warn($"No property found: '{to}'");
						return;
					}

					if (prop.operation is null) {
						if (bookProp.mod is null) {
							WriteLine($"obj.{to} = {from};");
						} else if (bookProp.mod == "array") {
							WriteLine($"{{ var tmp = {from}; if (tmp != null) obj.{to}.AddRange(tmp); }}");
						} else {
							throw new Exception("Unknown mod type: " + bookProp.mod);
						}
					} else if (prop.operation == "add") {
						WriteLine($"obj.{to}.Add({from});");
					} else if (prop.operation == "remove") {
						WriteLine($"obj.{to}.Remove({from});");
					} else
						throw new Exception("Unknown operation: " + prop.operation);
				}

				if (prop.from != null)
				{
					WriteMove($"msg.{prop.from}", prop.to);
				} else /* function */ {
					if (prop.function == "ReturnNone")
						WriteMove($"null", prop.tolist[0]);
					else if (prop.function == "VoidFun") { /* Do Nothing */ }
					else if(prop.tolist.Length == 0)
						WriteLine($"{prop.function}(msg);");
					else if (prop.tolist.Length == 1)
						WriteMove($"{prop.function}(msg)", prop.tolist[0]);
					else
					{
						WriteLine("{");
						WriteLine($"var tmp = {prop.function}(msg);", prop.to);
						for (int i = 0; i < prop.tolist.Length; i++)
							WriteMove($"tmp.Item{(i + 1)}", prop.tolist[i]);
						WriteLine("}");
					}
				}
			}
			if (rule.operation == "add") {
				WriteLine($"Set{rule.to}(obj{(string.IsNullOrEmpty(idStr) ? "" : (", " + idStr))});");
			}
			break;

		case "remove":#>
			Remove<#=rule.to#>(<#=idStr#>);<#
			break;
		} #>
		}

	<# } #>
#pragma warning restore IDE0017
	}
}