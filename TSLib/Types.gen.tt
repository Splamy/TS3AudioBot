// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />

<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
var types = new (string alias, string backing)[] {
	("Uid", "String"),
	("ClientDbId", "UInt64"),
	("ClientId", "UInt16"),
	("ChannelId", "UInt64"),
	("ServerGroupId", "UInt64"),
	("ChannelGroupId", "UInt64"),
	//("IconHash", "Int32"),
	//("ConnectionId", "UInt32"),
};
#>
#nullable enable
using Newtonsoft.Json;
using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;

namespace TSLib
{
	public static class TsTypes
	{
		public static Type[] All => new Type[] { <# foreach(var type in types) { Write($"typeof({type.alias}),"); } #> };
	}

	<# foreach(var type in types) {
		var isStr = type.backing.Equals("string",StringComparison.OrdinalIgnoreCase); #>
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(<#= type.alias #>.Converter))]
	public readonly partial struct <#= type.alias #> :<#= isStr ? "" : " IFormattable," #> IEquatable<<#= type.alias #>>
	{
		public static readonly <#= type.alias #> Null = new <#= type.alias #>(<#= isStr ? "string.Empty" : "default" #>);
		public static <#= type.alias #> To(<#= type.backing #> v) => new <#= type.alias #>(v);

		public <#= type.backing #> Value { get; }
		public <#= type.alias #>(<#= type.backing #> value) { <#= isStr ? "if (value == null) throw new ArgumentNullException(nameof(value));" : "" #> Value = value; }
		public static explicit operator <#= type.alias #>(<#= type.backing #> v) => new <#= type.alias #>(v);
		public static bool operator ==(<#= type.alias #> a, <#= type.alias #> b) => a.Value == b.Value;
		public static bool operator !=(<#= type.alias #> a, <#= type.alias #> b) => a.Value != b.Value;
		public override int GetHashCode() => <#= isStr ? "Value?.GetHashCode() ?? 0" : "Value.GetHashCode()" #> ;
		public override bool Equals(object? obj) => obj is <#= type.alias #> c && this.Equals(c);
		public override string ToString() => Value <#= isStr ? "?? \"\"" : ".ToString()" #>;
		<# if (isStr) { #>
		public bool Equals(<#= type.alias #> other) => string.Equals(Value, other.Value, StringComparison.Ordinal);
		<# } else { #>
		public bool Equals(<#= type.alias #> other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		<# } #>
		public static <#= type.alias #>? TryFrom(object value) {
			<# if (isStr) { #>
			if (value is string s) return new <#= type.alias #>(s);
			return null;
			<# } else { #>
			if (value is <#= type.backing #> bvalue) return new <#= type.alias #>(bvalue);
			if (value is string s && <#= type.backing #>.TryParse(s, out var num)) return new <#= type.alias #>(num);
			if (value is IConvertible c) return new <#= type.alias #>(c.To<#= type.backing #>(CultureInfo.InvariantCulture));

			return null;
			<# } #>
			
		}

		private class Converter : JsonConverter<<#= type.alias #>>
		{
			public override void WriteJson(JsonWriter writer, <#= type.alias #> value, JsonSerializer serializer)
				=> writer.WriteValue(value.Value);
			public override <#= type.alias #> ReadJson(JsonReader reader, Type objectType, <#= type.alias #> existingValue, bool hasExistingValue, JsonSerializer serializer)
				=> new <#= type.alias #>(<#= isStr ? "" : type.backing + ".Parse" #>(reader.ReadAsString() ?? throw new FormatException()));
		}
	}
	<# } #>
}